name: Remote Build (merge then push) & Deploy

on:
  push:
    # branches: [ "main" ]
  workflow_dispatch:

env:
  IMAGE_NAME: hiufungleung/healermy
  IMAGE_TAG: latest

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build_remote:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.read_digest.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 把原始碼複製到遠端（免去遠端 git 認證）
      - name: Copy source to remote
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.BUILD_HOST }}
          username: ${{ secrets.BUILD_USER }}
          key: ${{ secrets.BUILD_KEY }}
          source: "./"
          target: "~/gha-build/healermy"

      - name: Build 2 arch locally on remote, then merge & push once
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.BUILD_HOST }}
          username: ${{ secrets.BUILD_USER }}
          key: ${{ secrets.BUILD_KEY }}
          script: |
            set -euo pipefail
            cd ~/gha-build/healermy

            # 準備 buildx + qemu（DinD 或實機均可）
            docker buildx ls | grep -q gha-remote || docker buildx create --use --name gha-remote
            docker buildx inspect --bootstrap
            docker run --privileged --rm tonistiigi/binfmt --install all

            # 清理上一輪輸出
            rm -rf out-amd64 out-arm64
            mkdir -p out-amd64 out-arm64

            # 1) 各自 build 到本地 OCI 佈局（不推）
            docker buildx build \
              --platform linux/amd64 \
              --output=type=oci,dest=out-amd64/oci.tar \
              .

            docker buildx build \
              --platform linux/arm64 \
              --output=type=oci,dest=out-arm64/oci.tar \
              .

            # 2) 用 imagetools 把兩個佈局「合併」並一次 push 到 Docker Hub
            echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

            # 先把 tar 展開成 oci-layout 目錄（imagetools 支援 oci-layout: 路徑）
            rm -rf oci-amd64 oci-arm64
            mkdir -p oci-amd64 oci-arm64
            tar -xf out-amd64/oci.tar -C oci-amd64
            tar -xf out-arm64/oci.tar -C oci-arm64

            # 3) 合併並同時打兩個 tag（commit 與 latest），一次性 --push
            docker buildx imagetools create \
              --tag ${{ env.IMAGE_NAME }}:${{ github.sha }} \
              --tag ${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }} \
              oci-layout:oci-amd64 \
              oci-layout:oci-arm64 \
              --push

            # 4) 可選：清理暫存（避免磁碟吃滿）
            rm -rf out-* oci-*
            docker builder prune -f --keep-storage 4GB || true

      - name: Read pushed manifest digest
        id: read_digest
        run: |
          set -e
          DIGEST=$(docker buildx imagetools inspect "${{ env.IMAGE_NAME }}:${{ github.sha }}" --format '{{json .Manifest.Digest}}' | tr -d '"')
          echo "digest=$DIGEST" >> "$GITHUB_OUTPUT"

  deploy:
    runs-on: ubuntu-latest
    needs: build_remote
    steps:
      - name: Deploy over SSH (same as before)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_KEY }}
          script: |
            set -euo pipefail
            CONTAINER=healermy
            PORT=3000

            IMAGE="${{ env.IMAGE_NAME }}@${{ needs.build_remote.outputs.digest }}"

            echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
            docker network inspect web >/dev/null 2>&1 || docker network create web
            docker rm -f "$CONTAINER" 2>/dev/null || true
            docker pull "$IMAGE"
            docker run -d --name "$CONTAINER" \
              --network web \
              -e HOSTNAME=0.0.0.0 \
              -e PORT=$PORT \
              --restart unless-stopped \
              "$IMAGE"

            # 若由 Nginx 代理，可改用內網探活；這裡給一個容器內探活示例
            for i in {1..30}; do
              if docker run --rm --network web curlimages/curl:8.8.0 -fsS "http://$CONTAINER:$PORT/" >/dev/null; then
                echo "UP"; break
              fi
              sleep 2
            done